from PYGA_StandardGenAlgBehavior import PYGA_StandardGenAlgBehavior

class MyGenAlgBehavior(PYGA_StandardGenAlgBehavior):

    POPULATION_FILE = 'results/populationHistory.dat'
    PARETO_FILE = 'results/paretoHistory.dat'

    INDIV_GET_METHOD = []
    INDIV_METH_VALUE = []
    INDIV_METH_CMP = []

    def startOfGeneration(self, population, iGeneration):
        # Nothing to do right now...
        pass

    def endOfGeneration(self, population, iGeneration):
        # Write the whole population in the file
        fidpop = open(self.POPULATION_FILE, 'a')
        fidpop.write('*****************\n')
        fidpop.write('GENERATION: ' + str(iGeneration) + '\n')
        for indiv in population:
            fidpop.write(str(indiv) + ' - ' + indiv.getTextString() + '\n')
        fidpop.close()
        # Write the best individuals in the file
        fidpop = open(self.PARETO_FILE, 'a')
        fidpop.write('*****************\n')
        fidpop.write('GENERATION: ' + str(iGeneration) + '\n')
        for indiv in population.getBestIndividual():
            fidpop.write(str(indiv) + ' - ' + indiv.getTextString() + '\n')
        fidpop.close()

    def stopCriteria(self, population, iGeneration):
        # Check parmeters
        if len(self.INDIV_METH_CMP) != len(self.INDIV_METH_VALUE) or\
           len(self.INDIV_METH_CMP) != len(self.INDIV_GET_METHOD) or\
           len(self.INDIV_GET_METHOD) != len(self.INDIV_METH_VALUE):
            raise Exception, 'Error: Number of Methods/Value/Compaire are diffrents.'

        # Check only the best individuals
        for indiv in population.getBestIndividual():
            # Quantify "perfectness" of an individual
            perfectIndiv = True
            for i, meth in enumerate(self.INDIV_GET_METHOD):
                # Get the value of the individual for the current attribute
                value = eval('indiv.'+ meth +'()')
                # Get the objective value of this attribute
                objValue = self.INDIV_METH_VALUE[i]
                # Get the compaire method (Right now, only <, >, ==, <= or >=)
                cmpMeth = self.INDIV_METH_CMP[i]
                # Check the value...
                evalStr = str(value) + ' ' + cmpMeth + ' ' + str(objValue)
                try:
                    valueOk = eval(evalStr)
                except:
                    valueOk = False
                if not valueOk:
                    perfectIndiv = False
                    break
            if perfectIndiv:
                return True

        return False



    # Overload crossover
    # Do not cross individual with only one node
    def crossover(self, population, nbCrossInd, newPop):
        # 1- Create the new population
        # -- It will contain only all individuals generated by crossover
        crossedPopulation = self.createPopulation()
        # 2- Generate enought individuals
        while crossedPopulation.size() < nbCrossInd:
            # 2.1- Get the parents to cross
            crossOnce = self.getParam(self.CROSS_ONCE_LABEL)
            # 2.2- Call cross method from individual class
            duplicated = True
            while duplicated:
                parents = population.getRandomParents(useTwice=(not crossOnce))
                while 1 in [parents[0].getComplexity(), parents[1].getComplexity()]:
                    parents = population.getRandomParents(useTwice=(not crossOnce))
                newIndiv = self.individualCrossover(parents[0], parents[1])
                duplicated = False
                if self.getParam(self.DEL_DUPLICATED_INDIV_LABEL):
                    for indiv in newPop:
                        if newIndiv.isDuplication(indiv):
                            duplicated = True
                            break
                    if not duplicated:
                        for indiv in crossedPopulation:
                            if newIndiv.isDuplication(indiv):
                                duplicated = True
                                break
            crossedPopulation.addIndividual(newIndiv)
        return crossedPopulation
